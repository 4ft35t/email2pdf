#!/usr/bin/env python3

from datetime import datetime
from email.header import decode_header
from subprocess import Popen, PIPE
from sys import platform as _platform
import argparse
import email
import io
import logging
import logging.handlers
import magic
import os
import os.path
import re
import sys


def main():
    parser = argparse.ArgumentParser(description="Converts emails to PDFs. " +
                                     "See https://github.com/andrewferrier/email2pdf for more information.")

    parser.add_argument("-i", "--inputFile", default="-",
                        help="File containing input email you wish to read - in raw form " +
                        "delivered from a MTA. If set to '-' (which is the default), it " +
                        "reads from stdin.")

    output_options = parser.add_mutually_exclusive_group()

    output_options.add_argument("-o", "--outputFile",
                                help="Output file you wish to write to. Should " +
                                "include the complete path, otherwise it " +
                                "defaults to the current directory. If this is " +
                                "not specified, email2pdf picks a date & " +
                                "time-based filename and puts the file in the " +
                                "directory specified by --outputDirectory.")

    parser.add_argument("-d", "--outputDirectory", default=os.getcwd(),
                        help="Output directory when --outputFile is not specified. Defaults to the " +
                        "current directory.")

    parser.add_argument("--no-body", dest='body', action='store_false',
                        help="Don't parse the body of the email and print it to PDF, just detach relevant " +
                        "attachments. The default is to parse both the body and detach attachments.")

    parser.add_argument("--headers", action='store_true',
                        help="Add basic email headers to the PDF. The default is not to do this.")

    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Make the output more verbose. This affects both the output logged to " +
                        "syslog, as well as output to the console.")

    parser.set_defaults(body=True, headers=False)
    args = parser.parse_args()

    if args.verbose > 1:
        sysLogHandler.setLevel(logging.DEBUG)
        sysErrHandler.setLevel(logging.DEBUG)
    elif args.verbose == 1:
        sysLogHandler.setLevel(logging.DEBUG)
        sysErrHandler.setLevel(logging.INFO)
    else:
        sysLogHandler.setLevel(logging.INFO)
        sysErrHandler.setLevel(logging.WARNING)

    output_directory = os.path.normpath(args.outputDirectory)

    if not os.path.exists(output_directory):
        raise FatalException("outputDirectory does not exist.")

    if args.outputFile:
        output_file_name = args.outputFile
        if os.path.isfile(output_file_name):
            raise FatalException("Output file " + output_file_name + " already exists. Aborting.")
    else:
        output_file_name = os.path.join(output_directory, datetime.now().strftime("%Y-%m-%dT%H-%M-%S") + ".pdf")
        output_file_name = get_unique_version(output_file_name)

    logger.info("Output file name is: " + output_file_name)


    if args.inputFile.strip() == "-":
        data = ""
        for line in sys.stdin:
            data += line
    else:
        with open(args.inputFile, "r") as inputHandle:
            data = inputHandle.read()

    logger.debug("Email input data is: " + data)

    input_email = email.message_from_string(data)

    number_of_pdf_parts = handle_pdf_parts(input_email, output_directory)

    header_info = get_header_info(input_email)
    logger.info("Header info is: " + header_info)

    if not args.headers:
        header_info = ""

    if args.body:
        handle_message_body(input_email, header_info, output_file_name)
    elif number_of_pdf_parts == 0:
        raise WarningException("Didn't print body (on request) or extract any attachments.")

    if warning_pending:
        sys.exit(warning_pending.getExitCode())


def handle_message_body(input_email, header_info, output_file_name):
    part = find_part_by_content_type(input_email, "text/html")
    if part is None:
        part = find_part_by_content_type(input_email, "text/plain")
        if part is None:
            raise FatalException("Cannot find an appropriate payload in email.")
        else:
            logger.info("Determined email is Text.")
            payload = part.get_payload(decode=True)
            payload = bytes("<html><body><pre>\n", 'UTF-8') + payload + bytes("\n</pre></body></html>", 'UTF-8')
    else:
        logger.info("Determined email is HTML.")
        payload = part.get_payload(decode=True)

        def cid_replace(matchobj):
            logger.debug("Looking for image for cid " + matchobj.group(1))
            imagePart = find_part_by_content_id(input_email, matchobj.group(1))
            if imagePart is not None:
                assert(imagePart['Content-Transfer-Encoding'] == 'base64')
                imageBase64 = imagePart.get_payload(decode=False)
                imageBase64 = re.sub("[\r\n\t]", "", imageBase64)
                imageDecoded = imagePart.get_payload(decode=True)
                mimeType = get_mime_type(imageDecoded)
                return "data:" + mimeType + ";base64," + imageBase64
            else:
                raise WarningException("Could not find image cid " + matchobj.group(1) + " in email content.")
                return "broken"

        payload = bytes(re.sub('cid:([\w_-]+)', cid_replace, str(payload, encoding='utf-8')), 'UTF-8')

    payload = bytes(header_info, 'UTF-8') + payload

    logger.debug("Final payload before PDFing: " + str(payload, encoding='utf-8'))

    p = Popen(['wkhtmltopdf', '-q', '--load-error-handling', 'ignore', '--load-media-error-handling', 'ignore',
               '--encoding', 'utf-8', '-', output_file_name], stdin=PIPE, stdout=PIPE, stderr=PIPE)
    output, error = p.communicate(input=payload)
    if p.returncode > 0:
        raise FatalException("wkhtmltopdf failed with exit code " + str(p.returncode))


def handle_pdf_parts(input_email, output_directory):
    parts = find_all_parts(input_email, "application/pdf")
    maybeParts = find_all_parts(input_email, "application/octet-stream")

    for maybePart in maybeParts:
        filename = extract_part_filename(maybePart)
        unused_base, ext = os.path.splitext(filename)
        if ext.lower() == '.pdf':
            parts.append(maybePart)

    for part in parts:
        filename = extract_part_filename(part)
        logger.info("Extracting attachment " + filename)

        fullFilename = os.path.join(output_directory, filename)
        fullFilename = get_unique_version(fullFilename)

        payload = part.get_payload(decode=True)
        with open(fullFilename, 'wb') as output_file:
            output_file.write(payload)

    return len(parts)


def extract_part_filename(part):
    filename = part.get_filename()
    if decode_header(filename)[0][1] is not None:
        filename = str(decode_header(filename)[0][0]).decode(decode_header(filename)[0][1])
    return filename


def get_unique_version(filename):
    # From here: http://stackoverflow.com/q/183480/27641
    counter = 1
    file_name_parts = os.path.splitext(filename)
    while os.path.isfile(filename):
        filename = file_name_parts[0] + '_' + str(counter) + file_name_parts[1]
        counter += 1
    return filename


def find_part_by_content_type(message, content_type):
    for part in message.walk():
        if part.get_content_type() == content_type:
            return part
    return None


def find_part_by_content_id(message, content_id):
    for part in message.walk():
        if part['Content-ID'] in (content_id, '<' + content_id + '>'):
            return part
    return None


def find_all_parts(message, content_type):
    parts = []

    for part in message.walk():
        if part.get_content_type() == content_type:
            parts.append(part)

    return parts


def get_header_info(email):
    HEADERS = ('Subject', 'From', 'To', 'Date')

    header_info = ""

    for header in HEADERS:
        if(email[header]):
            header_info = header_info + '<b>' + header + '</b>: ' + email[header] + '<br/>'

    return header_info + '<br/>'

# There are various different magic libraries floating around for Python, and
# this function abstracts that out. The first clause is for `pip3 install
# python-magic`, and the second is for the Ubuntu package python3-magic.

def get_mime_type(bufferData):
    if 'from_buffer' in dir(magic):
        mimeType = str(magic.from_buffer(bufferData, True))
    else:
        m = magic.open(magic.MAGIC_MIME_TYPE)
        m.load()
        mimeType = m.buffer(bufferData)

    return mimeType

# Idea for this error handling strategy from here:
# http://stackoverflow.com/a/16787722/27641


class ExitCodeException(Exception):
    def __new__(cls, *args, **kwargs):
        if cls is ExitCodeException:
            raise NotImplementedError("ExitCodeException class may not be instantiated directly.")
        return Exception.__new__(cls, *args, **kwargs)

    def __init__(self, message):
        super().__init__()
        self._message = message

    def __str__(self):
        return repr(self._message)

    def getExitCode(self):
        """Return the exit code for this exception"""
        pass


class FatalException(ExitCodeException):
    def getExitCode(self):
        return 2


class WarningException(ExitCodeException):
    def getExitCode(self):
        return 1


def handle_uncaught_exception(exctype, value, trace):
    if isinstance(value, FatalException):
        logger.error(value)
        sys.exit(value.getExitCode())
    elif isinstance(value, WarningException):
        warning_pending = value
        logger.warn(value)
    else:
        logger.error(value)
        oldHook(exctype, value, trace)

sys.excepthook, oldHook = handle_uncaught_exception, sys.excepthook

warning_pending = None

# See http://stackoverflow.com/a/11111212/27641
logger = logging.getLogger('email2pdf')
logger.setLevel(logging.DEBUG)

if _platform == "linux" or _platform == "linux2":
    sysLogAddress = '/dev/log'
elif _platform == "darwin":
    sysLogAddress = '/var/run/syslog'
else:
    print("Unsupported platform.")
    sys.exit(3)

sysLogHandler = logging.handlers.SysLogHandler(address=sysLogAddress)
sysLogHandler.setLevel(logging.INFO)
sysLogFormatter = logging.Formatter('%(pathname)s[' + str(os.getpid()) + '] %(levelname)s %(lineno)s: %(message)s')
sysLogHandler.setFormatter(sysLogFormatter)
logger.addHandler(sysLogHandler)

sysErrHandler = logging.StreamHandler(stream=sys.stderr)
sysErrHandler.setLevel(logging.WARNING)
sysErrFormatter = logging.Formatter('%(levelname)s: %(message)s')
sysErrHandler.setFormatter(sysErrFormatter)
logger.addHandler(sysErrHandler)

if __name__ == "__main__":
    main()
