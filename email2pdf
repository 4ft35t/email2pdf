#!/usr/bin/env python3

from PyPDF2 import PdfFileReader, PdfFileWriter
from PyPDF2.generic import NameObject, createStringObject
from datetime import datetime
from email.header import decode_header
from html.parser import HTMLParser
from itertools import chain
from subprocess import Popen, PIPE
from sys import platform as _platform
import argparse
import base64
import email
import functools
import io
import logging
import logging.handlers
import magic
import os
import os.path
import re
import shutil
import sys
import tempfile
import urllib.request

HEADER_MAPPING = {'Author': 'From',
                  'Title': 'Subject',
                  'X-email2pdf-To': 'To'}

MIME_TYPES_ATTACHMENTS = [ 'application/pdf', 'image/jpeg', 'image/png' ]

MIME_TYPES_EXTENSIONS = [ '.pdf', '.jpeg', '.jpg', '.png' ]

def main():
    parser = argparse.ArgumentParser(description="Converts emails to PDFs. " +
                                     "See https://github.com/andrewferrier/email2pdf for more information.")

    parser.add_argument("-i", "--inputFile", default="-",
                        help="File containing input email you wish to read in raw form " +
                        "delivered from a MTA. If set to '-' (which is the default), it " +
                        "reads from stdin.")

    parser.add_argument("-o", "--outputFile",
                        help="Output file you wish to print the body of the email to as PDF. Should " +
                        "include the complete path, otherwise it defaults to the current directory. If " +
                        "this option is not specified, email2pdf picks a date & time-based filename and puts " +
                        "the file in the directory specified by --outputDirectory.")

    parser.add_argument("-d", "--outputDirectory", default=os.getcwd(),
                        help="Output directory when --outputFile is not specified. Defaults to the " +
                        "current directory.")

    body_attachment_options = parser.add_mutually_exclusive_group()

    body_attachment_options.add_argument("--no-body", dest='body', action='store_false',
                        help="Don't parse the body of the email and print it to PDF, just detach relevant " +
                        "attachments. The default is to parse both the body and detach attachments.")

    body_attachment_options.add_argument("--no-attachments", dest='attachments', action='store_false',
                        help="Don't detach the recognized attachment types (PDF and images), just print the body of " +
                        "the email to PDF.")

    parser.add_argument("--headers", action='store_true',
                        help="Add basic email headers to the first PDF page. The default is not to do this.")

    parser.add_argument("--add-prefix-date", dest="add_prefix_date", action="store_true",
                        help="Prepend an ISO-8601 prefix date (e.g. YYYY-MM-DD-) to any attachment filename " +
                        "that doesn't have one. Will search through the whole filename for an existing " +
                        "date in that format - if not found, it prepends one.")

    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Make the output more verbose. This affects both the output logged to " +
                        "syslog, as well as output to the console. Using this twice makes it doubly verbose.")

    parser.set_defaults(body=True, attachments=True, headers=False)
    args = parser.parse_args()

    if args.verbose > 1:
        sysLogHandler.setLevel(logging.DEBUG)
        sysErrHandler.setLevel(logging.DEBUG)
    elif args.verbose == 1:
        sysLogHandler.setLevel(logging.DEBUG)
        sysErrHandler.setLevel(logging.INFO)
    else:
        sysLogHandler.setLevel(logging.INFO)
        sysErrHandler.setLevel(logging.WARNING)

    logger.info("Options used are: " + str(args))

    output_directory = os.path.normpath(args.outputDirectory)

    if not os.path.exists(output_directory):
        raise FatalException("outputDirectory does not exist.")

    if args.outputFile:
        output_file_name = args.outputFile
        if os.path.isfile(output_file_name):
            raise FatalException("Output file " + output_file_name + " already exists. Aborting.")
    else:
        output_file_name = os.path.join(output_directory, datetime.now().strftime("%Y-%m-%dT%H-%M-%S") + ".pdf")
        output_file_name = get_unique_version(output_file_name)

    logger.info("Output file name is: " + output_file_name)

    if args.inputFile.strip() == "-":
        data = ""
        for line in sys.stdin:
            data += line
    else:
        with open(args.inputFile, "r") as inputHandle:
            data = inputHandle.read()

    logger.debug("Email input data is: " + data)

    input_email = email.message_from_string(data)

    if args.headers:
        header_info = get_formatted_header_info(input_email)
        logger.info("Header info is: " + header_info)
    else:
        header_info = ""

    if args.body:
        parts_already_used = handle_message_body(input_email, header_info, output_file_name)
    else:
        parts_already_used = []

    if args.attachments:
        number_of_attachments = handle_attachments(input_email, output_directory, args.add_prefix_date, parts_already_used)
    else:
        number_of_attachments = 0

    if (not args.body) and number_of_attachments == 0:
        raise WarningException("Didn't print body (on request) or extract any attachments.")

    if warning_pending:
        sys.exit(warning_pending.getExitCode())


def handle_message_body(input_email, header_info, output_file_name):
    cid_parts_used = []

    part = find_part_by_content_type(input_email, "text/html")
    if part is None:
        part = find_part_by_content_type(input_email, "text/plain")
        if part is None:
            raise FatalException("Cannot find an appropriate payload in email.")
        else:
            logger.info("Determined email is Text.")
            payload = part.get_payload(decode=True)
            payload = bytes("<html><body><pre>\n", 'UTF-8') + payload + bytes("\n</pre></body></html>", 'UTF-8')
    else:
        logger.info("Determined email is HTML.")
        payload = part.get_payload(decode=True)

        def cid_replace(cid_parts_used, matchobj):
            cid = matchobj.group(1)

            logger.debug("Looking for image for cid " + cid)
            imagePart = find_part_by_content_id(input_email, cid)
            if imagePart is not None:
                logger.info("Found cid image for " + cid + " in imagePart")
                assert(imagePart['Content-Transfer-Encoding'] == 'base64')
                imageBase64 = imagePart.get_payload(decode=False)
                imageBase64 = re.sub("[\r\n\t]", "", imageBase64)
                imageDecoded = imagePart.get_payload(decode=True)
                mimeType = get_mime_type(imageDecoded)
                cid_parts_used.append(imagePart)
                return "data:" + mimeType + ";base64," + imageBase64
            else:
                parser = FindIMGURL(cid)
                parser.feed(str(payload, encoding='utf-8'))
                url = parser.get_url()

                if url:
                    logger.info("Found cid image for " + cid + " with URL " + url)
                    response = urllib.request.urlopen(url)
                    data = response.read()
                    imageBase64 = str(base64.b64encode(data), 'utf-8')
                    mimeType = get_mime_type(data)
                    return "data:" + mimeType + ";base64," + imageBase64
                else:
                    raise WarningException("Could not find image cid " + matchobj.group(1) + " in email content.")
                    return "broken"

        payload = bytes(re.sub('cid:([\w\._-]+)', functools.partial(cid_replace, cid_parts_used), str(payload, encoding='utf-8')), 'UTF-8')

    payload = bytes(header_info, 'UTF-8') + payload

    logger.debug("Final payload before PDFing: " + str(payload, encoding='utf-8'))

    p = Popen(['wkhtmltopdf', '-q', '--load-error-handling', 'ignore', '--load-media-error-handling', 'ignore',
               '--encoding', 'utf-8', '-', output_file_name], stdin=PIPE, stdout=PIPE, stderr=PIPE)
    output, error = p.communicate(input=payload)
    if p.returncode > 0:
        raise FatalException("wkhtmltopdf failed with exit code " + str(p.returncode))

    add_metadata_obj = {}

    for key in HEADER_MAPPING:
        if HEADER_MAPPING[key] in input_email:
            add_metadata_obj[key] = input_email[HEADER_MAPPING[key]]

    add_metadata_obj['Producer'] = 'email2pdf'

    add_update_pdf_metadata(output_file_name, add_metadata_obj)

    return cid_parts_used


def handle_attachments(input_email, output_directory, add_prefix_date, parts_to_ignore):
    parts = []

    for content_type in MIME_TYPES_ATTACHMENTS:
        parts.extend(find_all_parts(input_email, content_type))

    for part in input_email.walk():
        if part not in parts:
            filename = extract_part_filename(part)
            if filename is not None:
                unused_base, ext = os.path.splitext(filename)
                if ext.lower() in MIME_TYPES_EXTENSIONS:
                    parts.append(part)

    for part in parts_to_ignore:
        parts.remove(part)

    for part in parts:
        filename = extract_part_filename(part)
        assert(filename is not None)

        if add_prefix_date:
            if not re.search("\d\d\d\d[-_]\d\d[-_]\d\d", filename):
                filename = datetime.now().strftime("%Y-%m-%d-") + filename

        logger.info("Extracting attachment " + filename)

        fullFilename = os.path.join(output_directory, filename)
        fullFilename = get_unique_version(fullFilename)

        payload = part.get_payload(decode=True)
        with open(fullFilename, 'wb') as output_file:
            output_file.write(payload)

    return len(parts)


def add_update_pdf_metadata(filename, updateDictionary):
    def addPrefix(value):
        return '/' + value

    fullUpdateDictionary = {addPrefix(k): v for k, v in updateDictionary.items()}

    with open(filename, 'rb') as input_file:
        pdf_input = PdfFileReader(input_file)
        pdf_output = PdfFileWriter()

        for page in range(pdf_input.getNumPages()):
            pdf_output.addPage(pdf_input.getPage(page))

        infoDict = pdf_output._info.getObject()

        info = pdf_input.documentInfo

        fullUpdateDictionary = dict(chain(info.items(), fullUpdateDictionary.items()))

        for key in fullUpdateDictionary:
            if fullUpdateDictionary[key] is not None:
                infoDict.update({NameObject(key): createStringObject(fullUpdateDictionary[key])})
            else:
                infoDict.update({NameObject(key): None})

        unused_f_handle, temp_file_name = tempfile.mkstemp(prefix="email2pdf_add_update_pdf_metadata", suffix=".pdf")

        with open(temp_file_name, 'wb') as file_out:
            pdf_output.write(file_out)

    shutil.move(temp_file_name, filename)


def extract_part_filename(part):
    filename = part.get_filename()
    if filename is not None:
        if decode_header(filename)[0][1] is not None:
            filename = str(decode_header(filename)[0][0]).decode(decode_header(filename)[0][1])
        return filename
    else:
        return None


def get_unique_version(filename):
    # From here: http://stackoverflow.com/q/183480/27641
    counter = 1
    file_name_parts = os.path.splitext(filename)
    while os.path.isfile(filename):
        filename = file_name_parts[0] + '_' + str(counter) + file_name_parts[1]
        counter += 1
    return filename


def find_part_by_content_type(message, content_type):
    for part in message.walk():
        if part.get_content_type() == content_type:
            return part
    return None


def find_part_by_content_id(message, content_id):
    for part in message.walk():
        if part['Content-ID'] in (content_id, '<' + content_id + '>'):
            return part
    return None


def find_all_parts(message, content_type):
    parts = []

    for part in message.walk():
        if part.get_content_type() == content_type:
            parts.append(part)

    return parts


def get_formatted_header_info(email):
    HEADERS = ('Subject', 'From', 'To', 'Date')

    header_info = ""

    for header in HEADERS:
        if(email[header]):
            header_info = header_info + '<b>' + header + '</b>: ' + email[header] + '<br/>'

    return header_info + '<br/>'

# There are various different magic libraries floating around for Python, and
# this function abstracts that out. The first clause is for `pip3 install
# python-magic`, and the second is for the Ubuntu package python3-magic.


def get_mime_type(bufferData):
    if 'from_buffer' in dir(magic):
        mimeType = str(magic.from_buffer(bufferData, mime=True), 'utf-8')
    else:
        m = magic.open(magic.MAGIC_MIME_TYPE)
        m.load()
        mimeType = m.buffer(bufferData)

    return mimeType


class FindIMGURL(HTMLParser):
    def __init__(self, image_filename):
        super().__init__()
        self.image_filename = image_filename

    def handle_starttag(self, tag, attrs):
        for (name, value) in attrs:
            if name == 'src' and value.lower().find("cid") == -1 and value.lower().endswith(self.image_filename.lower()):
                self.url = value

    def get_url(self):
        return self.url

# Idea for this error handling strategy from here:
# http://stackoverflow.com/a/16787722/27641


class ExitCodeException(Exception):
    def __new__(cls, *args, **kwargs):
        if cls is ExitCodeException:
            raise NotImplementedError("ExitCodeException class may not be instantiated directly.")
        return Exception.__new__(cls, *args, **kwargs)

    def __init__(self, message):
        super().__init__()
        self._message = message

    def __str__(self):
        return repr(self._message)

    def getExitCode(self):
        """Return the exit code for this exception"""
        pass


class FatalException(ExitCodeException):
    def getExitCode(self):
        return 2


class WarningException(ExitCodeException):
    def getExitCode(self):
        return 1


def handle_uncaught_exception(exctype, value, trace):
    if isinstance(value, FatalException):
        logger.error(value)
        sys.exit(value.getExitCode())
    elif isinstance(value, WarningException):
        warning_pending = value
        logger.warn(value)
    else:
        logger.error(value)
        oldHook(exctype, value, trace)

sys.excepthook, oldHook = handle_uncaught_exception, sys.excepthook

warning_pending = None

# See http://stackoverflow.com/a/11111212/27641
logger = logging.getLogger('email2pdf')
logger.setLevel(logging.DEBUG)

if _platform == "linux" or _platform == "linux2":
    sysLogAddress = '/dev/log'
elif _platform == "darwin":
    sysLogAddress = '/var/run/syslog'
else:
    print("Unsupported platform.")
    sys.exit(3)

sysLogHandler = logging.handlers.SysLogHandler(address=sysLogAddress)
sysLogHandler.setLevel(logging.INFO)
sysLogFormatter = logging.Formatter('%(pathname)s[' + str(os.getpid()) + '] %(levelname)s %(lineno)s: %(message)s')
sysLogHandler.setFormatter(sysLogFormatter)
logger.addHandler(sysLogHandler)

sysErrHandler = logging.StreamHandler(stream=sys.stderr)
sysErrHandler.setLevel(logging.WARNING)
sysErrFormatter = logging.Formatter('%(levelname)s: %(message)s')
sysErrHandler.setFormatter(sysErrFormatter)
logger.addHandler(sysErrHandler)

if __name__ == "__main__":
    main()
