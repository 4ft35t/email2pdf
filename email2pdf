#!/usr/bin/env python3

from bs4 import BeautifulSoup
from datetime import datetime
from email.header import decode_header
from itertools import chain
from PyPDF2.generic import NameObject, createStringObject
from PyPDF2 import PdfFileReader, PdfFileWriter
from subprocess import Popen, PIPE
from sys import platform as _platform
import argparse
import email
import functools
import logging
import logging.handlers
import magic
import mimetypes
import os
import os.path
import re
import requests
import shutil
import sys
import tempfile

HEADER_MAPPING = {'Author': 'From',
                  'Title': 'Subject',
                  'X-email2pdf-To': 'To'}

MIME_TYPES_BLACKLIST = set(['text/html', 'text/plain'])

AUTOCALCULATED_FILENAME_EXTENSION_BLACKLIST = set(['.jpe', '.jpeg'])

AUTOGENERATED_ATTACHMENT_PREFIX = 'floating_attachment'


def main(argv, sysLogHandler, sysErrHandler):
    logger = logging.getLogger('email2pdf')

    mimetypes.init()

    class ArgumentParser(argparse.ArgumentParser):
        def error(self, message):
            raise FatalException(message)

    parser = ArgumentParser(description="Converts emails to PDFs. "
                            "See https://github.com/andrewferrier/email2pdf for more information.", add_help=False)

    parser.add_argument("-i", "--inputFile", default="-",
                        help="File containing input email you wish to read in raw form "
                        "delivered from a MTA. If set to '-' (which is the default), it "
                        "reads from stdin.")

    parser.add_argument("-o", "--outputFile",
                        help="Output file you wish to print the body of the email to as PDF. Should "
                        "include the complete path, otherwise it defaults to the current directory. If "
                        "this option is not specified, email2pdf picks a date & time-based filename and puts "
                        "the file in the directory specified by --outputDirectory.")

    parser.add_argument("-d", "--outputDirectory", default=os.getcwd(),
                        help="Output directory for body PDF file when --outputFile is not specified. Defaults to the "
                        "current directory. Also used as the directory in which attachments are stored (even if -o is "
                        "specified).")

    body_attachment_options = parser.add_mutually_exclusive_group()

    body_attachment_options.add_argument("--no-body", dest='body', action='store_false', default=True,
                                         help="Don't parse the body of the email and print it to PDF, just detach "
                                         "attachments. The default is to parse both the body and detach attachments.")

    body_attachment_options.add_argument("--no-attachments", dest='attachments', action='store_false', default=True,
                                         help="Don't detach attachments, just print the body of the email to PDF.")

    parser.add_argument("--headers", action='store_true',
                        help="Add basic email headers to the first PDF page. The default is not to do this.")

    parser.add_argument("--add-prefix-date", action="store_true",
                        help="Prepend an ISO-8601 prefix date (e.g. YYYY-MM-DD-) to any attachment filename "
                        "that doesn't have one. Will search through the whole filename for an existing "
                        "date in that format - if not found, it prepends one.")

    parser.add_argument("--ignore-floating-attachments", action="store_true",
                        help="Emails sometimes contain attachments that don't have a filename and aren't "
                        "embedded in the main HTML body of the email using a Content-ID either. By "
                        "default, email2pdf will detach these and use their Content-ID as a filename, "
                        "or autogenerate a filename. If this option is specified, it will instead ignore "
                        "them.")

    parser.add_argument('-v', '--verbose', action='count', default=0,
                        help="Make the output more verbose. This affects both the output logged to "
                        "syslog, as well as output to the console. Using this twice makes it doubly verbose.")

    parser.add_argument('-h', '--help', action='store_true',
                        help="Show some basic help information about how to use email2pdf.")

    args = parser.parse_args(argv[1:])

    if args.help:
        parser.print_help()
        return

    if sysLogHandler:
        if args.verbose > 1:
            sysLogHandler.setLevel(logging.DEBUG)
        elif args.verbose == 1:
            sysLogHandler.setLevel(logging.DEBUG)
        else:
            sysLogHandler.setLevel(logging.INFO)

    if sysErrHandler:
        if args.verbose > 1:
            sysErrHandler.setLevel(logging.DEBUG)
        elif args.verbose == 1:
            sysErrHandler.setLevel(logging.INFO)
        else:
            sysErrHandler.setLevel(logging.WARNING)

    logger.info("Options used are: " + str(args))

    output_directory = os.path.normpath(args.outputDirectory)

    if not os.path.exists(output_directory):
        raise FatalException("outputDirectory does not exist.")

    if args.outputFile:
        output_file_name = args.outputFile
        if os.path.isfile(output_file_name):
            raise FatalException("Output file " + output_file_name + " already exists.")
    else:
        output_file_name = os.path.join(output_directory, datetime.now().strftime("%Y-%m-%dT%H-%M-%S") + ".pdf")
        output_file_name = get_unique_version(output_file_name)

    logger.info("Output file name is: " + output_file_name)

    if args.inputFile.strip() == "-":
        data = ""
        for line in sys.stdin:
            data += line
    else:
        with open(args.inputFile, "r") as inputHandle:
            data = inputHandle.read()

    logger.debug("Email input data is: " + data)

    input_email = email.message_from_string(data)

    # See https://docs.python.org/3/library/email.message.html. I've never
    # seen this defects array get populated in the wild, so I'm not 100% sure
    # it's being checked for correctly. But since it's hard to prove a
    # negative, I'm leaving it here for safety.
    assert(not input_email.defects)
    for part in input_email.walk():
        assert(not part.defects)

    if args.headers:
        header_info = get_formatted_header_info(input_email)
        logger.info("Header info is: " + header_info)
    else:
        header_info = ""

    (payload, parts_already_used) = handle_message_body(input_email, header_info)

    logger.debug("Payload after handle_message_body: " + payload)

    payload = remove_invalid_urls(payload)

    if args.body:
        logger.debug("Final payload before output_body_pdf: " + payload)
        output_body_pdf(input_email, bytes(payload, 'UTF-8'), output_file_name)

    if args.attachments:
        number_of_attachments = handle_attachments(input_email,
                                                   output_directory,
                                                   args.add_prefix_date,
                                                   args.ignore_floating_attachments,
                                                   parts_already_used)
    else:
        number_of_attachments = 0

    if (not args.body) and number_of_attachments == 0:
        warning("Didn't print body (on request) or extract any attachments.")


def handle_message_body(input_email, header_info):
    logger = logging.getLogger("email2pdf")

    cid_parts_used = set()

    part = find_part_by_content_type(input_email, "text/html")
    if part is None:
        part = find_part_by_content_type(input_email, "text/plain")
        if part is None:
            raise FatalException("Cannot find an appropriate payload in email.")
        else:
            payload = part.get_payload(decode=True)
            charset = part.get_content_charset()
            if not charset:
                charset = 'utf-8'
            logger.info("Determined email is plain text with charset " + str(charset))
            payload = "<html><body><pre>\n" + str(payload, charset) + "\n</pre></body></html>"
    else:
        payload = part.get_payload(decode=True)
        charset = part.get_content_charset()
        if not charset:
            charset = 'utf-8'
        logger.info("Determined email is HTML with charset " + str(charset))

        def cid_replace(cid_parts_used, matchobj):
            logger.debug("Looking for image for cid " + matchobj.group(1))
            imagePart = find_part_by_content_id(input_email, matchobj.group(1))
            if imagePart is not None:
                assert(imagePart['Content-Transfer-Encoding'] == 'base64')
                imageBase64 = imagePart.get_payload(decode=False)
                imageBase64 = re.sub("[\r\n\t]", "", imageBase64)
                imageDecoded = imagePart.get_payload(decode=True)
                mimeType = get_mime_type(imageDecoded)
                cid_parts_used.add(imagePart)
                return "data:" + mimeType + ";base64," + imageBase64
            else:
                warning("Could not find image cid " + matchobj.group(1) + " in email content.")
                return "broken"

        payload = re.sub('cid:([\w_-]+)', functools.partial(cid_replace, cid_parts_used),
                               str(payload, charset))

    return (header_info + payload, cid_parts_used)


def output_body_pdf(input_email, payload, output_file_name):
    p = Popen(['wkhtmltopdf', '-q', '--load-error-handling', 'ignore', '--load-media-error-handling', 'ignore',
               '--encoding', 'utf-8', '-', output_file_name], stdin=PIPE, stdout=PIPE, stderr=PIPE)
    output, error = p.communicate(input=payload)
    assert(output == b'')
    assert(error == b'')
    if p.returncode > 0:
        raise FatalException("wkhtmltopdf failed with exit code " + str(p.returncode) + ", error: " + str(error, 'utf-8'))

    add_metadata_obj = {}

    for key in HEADER_MAPPING:
        if HEADER_MAPPING[key] in input_email:
            add_metadata_obj[key] = input_email[HEADER_MAPPING[key]]

    add_metadata_obj['Producer'] = 'email2pdf'

    add_update_pdf_metadata(output_file_name, add_metadata_obj)


def remove_invalid_urls(payload):
    logger = logging.getLogger("email2pdf")

    soup = BeautifulSoup(payload, "lxml")

    for img in soup.find_all('img'):
        src = img['src']
        if not (src.lower().startswith('data')):
            logger.debug("Getting img URL " + src)

            try:
                r = requests.get(src, headers={'Connection': 'close'})
                r.raise_for_status()
            except:
                logger.warning("Could not retrieve img URL " + src + ", replacing with blank.")
                del img['src']
        else:
            logger.debug("Ignoring URL " + src)

    return str(soup)


def handle_attachments(input_email, output_directory, add_prefix_date, ignore_floating_attachments, parts_to_ignore):
    logger = logging.getLogger("email2pdf")

    parts = find_all_attachments(input_email, parts_to_ignore)

    for part in parts:
        filename = extract_part_filename(part)
        if not filename:
            if ignore_floating_attachments:
                continue

            filename = get_content_id(part)
            if not filename:
                filename = AUTOGENERATED_ATTACHMENT_PREFIX

            extension = get_type_extension(part.get_content_type())
            if extension:
                filename = filename + extension

        assert(filename is not None)

        if add_prefix_date:
            if not re.search("\d\d\d\d[-_]\d\d[-_]\d\d", filename):
                filename = datetime.now().strftime("%Y-%m-%d-") + filename

        logger.info("Extracting attachment " + filename)

        fullFilename = os.path.join(output_directory, filename)
        fullFilename = get_unique_version(fullFilename)

        payload = part.get_payload(decode=True)
        with open(fullFilename, 'wb') as output_file:
            output_file.write(payload)

    return len(parts)


def add_update_pdf_metadata(filename, updateDictionary):
    def addPrefix(value):
        return '/' + value

    fullUpdateDictionary = {addPrefix(k): v for k, v in updateDictionary.items()}

    with open(filename, 'rb') as input_file:
        pdf_input = PdfFileReader(input_file)
        pdf_output = PdfFileWriter()

        for page in range(pdf_input.getNumPages()):
            pdf_output.addPage(pdf_input.getPage(page))

        infoDict = pdf_output._info.getObject()

        info = pdf_input.documentInfo

        fullUpdateDictionary = dict(chain(info.items(), fullUpdateDictionary.items()))

        for key in fullUpdateDictionary:
            if fullUpdateDictionary[key] is not None:
                infoDict.update({NameObject(key): createStringObject(fullUpdateDictionary[key])})
            else:
                infoDict.update({NameObject(key): None})

        unused_f_handle, temp_file_name = tempfile.mkstemp(prefix="email2pdf_add_update_pdf_metadata", suffix=".pdf")

        with open(temp_file_name, 'wb') as file_out:
            pdf_output.write(file_out)

    shutil.move(temp_file_name, filename)


def extract_part_filename(part):
    filename = part.get_filename()
    if filename is not None:
        if decode_header(filename)[0][1] is not None:
            filename = str(decode_header(filename)[0][0]).decode(decode_header(filename)[0][1])
        return filename
    else:
        return None


def get_unique_version(filename):
    # From here: http://stackoverflow.com/q/183480/27641
    counter = 1
    file_name_parts = os.path.splitext(filename)
    while os.path.isfile(filename):
        filename = file_name_parts[0] + '_' + str(counter) + file_name_parts[1]
        counter += 1
    return filename


def find_part_by_content_type(message, content_type):
    for part in message.walk():
        if part.get_content_type() == content_type:
            return part
    return None


def find_part_by_content_id(message, content_id):
    for part in message.walk():
        if part['Content-ID'] in (content_id, '<' + content_id + '>'):
            return part
    return None


def get_content_id(part):
    content_id = part['Content-ID']
    if content_id:
        content_id = content_id.lstrip('<').rstrip('>')

    return content_id


def get_type_extension(content_type):
    filetypes = set(mimetypes.guess_all_extensions(content_type)) - AUTOCALCULATED_FILENAME_EXTENSION_BLACKLIST

    if len(filetypes) > 0:
        return sorted(list(filetypes))[0]
    else:
        return None


def find_all_attachments(message, parts_to_ignore):
    parts = set()

    for part in message.walk():
        if part not in parts_to_ignore and not part.is_multipart():
            if part.get_content_type() not in MIME_TYPES_BLACKLIST:
                parts.add(part)

    return parts


def get_formatted_header_info(email):
    HEADERS = ('Subject', 'From', 'To', 'Date')

    header_info = ""

    for header in HEADERS:
        if(email[header]):
            header_info = header_info + '<b>' + header + '</b>: ' + email[header] + '<br/>'

    return header_info + '<br/>'

# There are various different magic libraries floating around for Python, and
# this function abstracts that out. The first clause is for `pip3 install
# python-magic`, and the second is for the Ubuntu package python3-magic.


def get_mime_type(bufferData):
    if 'from_buffer' in dir(magic):
        mimeType = str(magic.from_buffer(bufferData, mime=True), 'utf-8')
    else:
        m = magic.open(magic.MAGIC_MIME_TYPE)
        m.load()
        mimeType = m.buffer(bufferData)

    return mimeType

warning_pending = False


def warning(message):
    global warning_pending
    logger = logging.getLogger("email2pdf")
    logger.warning(message)
    warning_pending = True


class FatalException(Exception):
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)

if __name__ == "__main__":
    logger = logging.getLogger("email2pdf")
    logger.propagate = False
    logger.setLevel(logging.DEBUG)

    if _platform == "linux" or _platform == "linux2":
        sysLogAddress = '/dev/log'
    elif _platform == "darwin":
        sysLogAddress = '/var/run/syslog'
    else:
        print("Unsupported platform.")
        sys.exit(3)

    sysLogHandler = logging.handlers.SysLogHandler(address=sysLogAddress)
    sysLogHandler.setLevel(logging.INFO)
    sysLogFormatter = logging.Formatter('%(pathname)s[%(process)d] %(levelname)s %(lineno)d %(message)s')
    sysLogHandler.setFormatter(sysLogFormatter)
    logger.addHandler(sysLogHandler)

    sysErrHandler = logging.StreamHandler(stream=sys.stderr)
    sysErrHandler.setLevel(logging.WARNING)
    sysErrFormatter = logging.Formatter('%(levelname)s: %(message)s')
    sysErrHandler.setFormatter(sysErrFormatter)
    logger.addHandler(sysErrHandler)

    try:
        main(sys.argv, sysLogHandler, sysErrHandler)
    except FatalException as e:
        logger.error(e.value)
        sys.exit(2)
    except:
        logger.error(str(sys.exc_info()[0], 'utf-8'))
        logger.error(sys.exc_info()[1])
        logger.error(str(sys.exc_info()[2], 'utf-8'))
        sys.exit(3)

    if warning_pending:
        sys.exit(1)
