#!/usr/bin/env python3

from datetime import datetime
from subprocess import Popen, PIPE
from email.header import decode_header
import argparse
import email
import os
import os.path
import sys


def main():
    parser = argparse.ArgumentParser(description="Converts emails to PDFs. " +
                                     "See https://github.com/andrewferrier/email2pdf for more information.")

    parser.add_argument("-i", "--inputFile", default="-",
                        help="Input file you wish to read. If set to '-' " +
                        "(which is the default), it reads from stdin.")

    output_options = parser.add_mutually_exclusive_group()

    output_options.add_argument("-o", "--outputFile",
                                help="Output file you wish to write to.")
    output_options.add_argument("-t", "--timedOutputFile",
                                help="Specify that email2pdf should automatically " +
                                "pick a filename based on the current date and time. " +
                                "This is the default if no output filename is specified.")

    parser.add_argument("-d", "--outputDirectory", default=os.getcwd(),
                        help="Output directory for --timedOutputFile. Defaults to the current directory.")

    parser.add_argument("--headers", dest='headers', action='store_true',
                        help="Add basic email headers to the PDF. The default is not to do this.")
    parser.set_defaults(headers=False)

    args = parser.parse_args()

    output_directory = os.path.normpath(args.outputDirectory)

    if not os.path.exists(output_directory):
        raise ExitCodeException("outputDirectory does not exist.")

    if args.outputFile:
        output_file_name = args.outputFile
    else:
        output_file_name = os.path.join(output_directory, datetime.now().strftime("%Y-%m-%dT%H-%M-%S") + ".pdf")

    if os.path.isfile(output_file_name):
        raise ExitCodeException("Output file " + output_file_name + " already exists. Aborting.")

    if args.inputFile.strip() == "-":
        data = ""
        for line in sys.stdin:
            data += line
    else:
        with open(args.inputFile, "r") as inputHandle:
            data = inputHandle.read()

    my_email = email.message_from_string(data)

    if(args.headers):
        header_info = get_header_info(my_email)
    else:
        header_info = ""

    part = find_depth_first(my_email, "application/pdf")
    if part is None:
        part = find_depth_first(my_email, "text/html")
        if part is None:
            part = find_depth_first(my_email, "text/plain")
            if part is None:
                raise ExitCodeException("Cannot find an appropriate payload in email.")
            else:
                payload = part.get_payload(decode=True)
                payload = bytes("<html><body><pre>\n", 'UTF-8') + payload + bytes("\n</pre></body></html>", 'UTF-8')
        else:
            payload = part.get_payload(decode=True)

        payload = bytes(header_info, 'UTF-8') + payload

        p = Popen(['wkhtmltopdf', '-q', '--load-error-handling', 'ignore', '--load-media-error-handling',
                   'ignore', '-', output_file_name], stdin=PIPE)
        output = p.communicate(input=payload)
    else:
        payload = part.get_payload(decode=True)

        filename = part.get_filename()
        if decode_header(filename)[0][1] is not None:
            filename = str(decode_header(filename)[0][0]).decode(decode_header(filename)[0][1])

        fullFilename = os.path.join(output_directory, filename)

        fullFilename = get_unique_version(fullFilename)

        with open(fullFilename, 'wb') as output_file:
            output_file.write(payload)


def get_unique_version(filename):
    # From here: http://stackoverflow.com/q/183480/27641
    counter = 1
    file_name_parts = os.path.splitext(filename)
    while os.path.isfile(filename):
        filename = file_name_parts[0] + '_' + str(counter) + file_name_parts[1]
        counter += 1
    return filename


def find_depth_first(message, content_type):
    if message.is_multipart():
        for part in message.get_payload():
            value = find_depth_first(part, content_type)
            if value is not None:
                return value
    elif message.get_content_type() == content_type:
        return message
    else:
        return None


def get_header_info(email):
    HEADERS = ('Subject', 'From', 'To', 'Date')

    header_info = ""

    for header in HEADERS:
        if(email[header]):
            header_info = header_info + '<b>' + header + '</b>: ' + email[header] + '<br/>'

    return header_info + '<br/>'

# Idea for this error handling strategy from here:
# http://stackoverflow.com/a/16787722/27641


class ExitCodeException(Exception):
    def __init__(self, message):
        self.message = message

    def __str__(self):
        return repr(self.message)

    def getExitCode(self):
        return 2


def handle_uncaught_exception(exctype, value, trace):
    if isinstance(value, ExitCodeException):
        print("ERROR: " + value.message, file=sys.stderr)
        sys.exit(value.getExitCode())
    else:
        oldHook(exctype, value, trace)

sys.excepthook, oldHook = handle_uncaught_exception, sys.excepthook

if __name__ == "__main__":
    main()
